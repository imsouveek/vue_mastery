"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateComponent = generateComponent;
exports.generateComponentSetupReturns = generateComponentSetupReturns;
exports.generateEmitsOption = generateEmitsOption;
exports.generatePropsOption = generatePropsOption;
const codeFeatures_1 = require("../codeFeatures");
const utils_1 = require("../utils");
function* generateComponent(options, ctx, scriptSetup, scriptSetupRanges) {
    if (options.sfc.script && options.scriptRanges?.exportDefault
        && options.scriptRanges.exportDefault.expression.start !== options.scriptRanges.exportDefault.args.start) {
        // use defineComponent() from user space code if it exist
        yield (0, utils_1.generateSfcBlockSection)(options.sfc.script, options.scriptRanges.exportDefault.expression.start, options.scriptRanges.exportDefault.args.start, codeFeatures_1.codeFeatures.all);
        yield `{${utils_1.newLine}`;
    }
    else {
        yield `(await import('${options.vueCompilerOptions.lib}')).defineComponent({${utils_1.newLine}`;
    }
    yield `setup() {${utils_1.newLine}`;
    yield `return {${utils_1.newLine}`;
    if (ctx.bypassDefineComponent) {
        yield* generateComponentSetupReturns(scriptSetupRanges);
    }
    if (scriptSetupRanges.defineExpose) {
        yield `...__VLS_exposed,${utils_1.newLine}`;
    }
    yield `}${utils_1.endOfLine}`;
    yield `},${utils_1.newLine}`;
    if (!ctx.bypassDefineComponent) {
        const emitOptionCodes = [...generateEmitsOption(options, scriptSetupRanges)];
        yield* emitOptionCodes;
        yield* generatePropsOption(options, ctx, scriptSetup, scriptSetupRanges, !!emitOptionCodes.length, true);
    }
    if (options.vueCompilerOptions.target >= 3.5
        && options.vueCompilerOptions.inferComponentDollarRefs
        && options.templateCodegen?.templateRefs.size) {
        yield `__typeRefs: {} as __VLS_TemplateRefs,${utils_1.newLine}`;
    }
    if (options.vueCompilerOptions.target >= 3.5
        && options.vueCompilerOptions.inferComponentDollarEl
        && options.templateCodegen?.singleRootElTypes.length) {
        yield `__typeEl: {} as __VLS_RootEl,${utils_1.newLine}`;
    }
    if (options.sfc.script && options.scriptRanges?.exportDefault?.args) {
        const { args } = options.scriptRanges.exportDefault;
        yield (0, utils_1.generateSfcBlockSection)(options.sfc.script, args.start + 1, args.end - 1, codeFeatures_1.codeFeatures.all);
    }
    yield `})`;
}
function* generateComponentSetupReturns(scriptSetupRanges) {
    // fill $props
    if (scriptSetupRanges.defineProps) {
        // NOTE: defineProps is inaccurate for $props
        yield `$props: __VLS_makeOptional(${scriptSetupRanges.defineProps.name ?? `__VLS_props`}),${utils_1.newLine}`;
        yield `...${scriptSetupRanges.defineProps.name ?? `__VLS_props`},${utils_1.newLine}`;
    }
    // fill $emit
    if (scriptSetupRanges.defineEmits) {
        yield `$emit: ${scriptSetupRanges.defineEmits.name ?? '__VLS_emit'},${utils_1.newLine}`;
    }
}
function* generateEmitsOption(options, scriptSetupRanges) {
    const optionCodes = [];
    const typeOptionCodes = [];
    if (scriptSetupRanges.defineModel.length) {
        optionCodes.push(`{} as __VLS_NormalizeEmits<typeof __VLS_modelEmit>`);
        typeOptionCodes.push(`__VLS_ModelEmit`);
    }
    if (scriptSetupRanges.defineEmits) {
        const { name, typeArg, hasUnionTypeArg } = scriptSetupRanges.defineEmits;
        optionCodes.push(`{} as __VLS_NormalizeEmits<typeof ${name ?? '__VLS_emit'}>`);
        if (typeArg && !hasUnionTypeArg) {
            typeOptionCodes.push(`__VLS_Emit`);
        }
        else {
            typeOptionCodes.length = 0;
        }
    }
    if (options.vueCompilerOptions.target >= 3.5 && typeOptionCodes.length) {
        yield* generateIntersectMerge('__typeEmits', typeOptionCodes);
    }
    else if (optionCodes.length) {
        yield* generateSpreadMerge('emits', optionCodes);
    }
}
function* generatePropsOption(options, ctx, scriptSetup, scriptSetupRanges, hasEmitsOption, inheritAttrs) {
    const getOptionCodes = [];
    const typeOptionCodes = [];
    if (inheritAttrs && options.templateCodegen?.inheritedAttrVars.size) {
        let attrsType = `Partial<__VLS_InheritedAttrs>`;
        if (hasEmitsOption) {
            attrsType = `Omit<${attrsType}, \`on\${string}\`>`;
        }
        getOptionCodes.push(() => {
            const propsType = `__VLS_PickNotAny<${ctx.localTypes.OmitIndexSignature}<${attrsType}>, {}>`;
            const optionType = `${ctx.localTypes.TypePropsToOption}<${propsType}>`;
            return `{} as ${optionType}`;
        });
        typeOptionCodes.push(`{} as ${attrsType}`);
    }
    if (ctx.generatedPropsType) {
        if (options.vueCompilerOptions.target < 3.6) {
            getOptionCodes.push(() => {
                const propsType = `${ctx.localTypes.TypePropsToOption}<__VLS_PublicProps>`;
                return `{} as ` + (scriptSetupRanges.withDefaults?.arg
                    ? `${ctx.localTypes.WithDefaults}<${propsType}, typeof __VLS_withDefaultsArg>`
                    : propsType);
            });
        }
        typeOptionCodes.push(`{} as __VLS_PublicProps`);
    }
    if (scriptSetupRanges.defineProps?.arg) {
        const { arg } = scriptSetupRanges.defineProps;
        getOptionCodes.push(() => (0, utils_1.generateSfcBlockSection)(scriptSetup, arg.start, arg.end, codeFeatures_1.codeFeatures.navigation));
        typeOptionCodes.length = 0;
    }
    const useTypeOption = options.vueCompilerOptions.target >= 3.5 && typeOptionCodes.length;
    const useOption = (!useTypeOption || scriptSetupRanges.withDefaults) && getOptionCodes.length;
    if (useTypeOption) {
        if (options.vueCompilerOptions.target >= 3.6
            && scriptSetupRanges.withDefaults?.arg) {
            yield `__defaults: __VLS_withDefaultsArg,${utils_1.newLine}`;
        }
        yield* generateSpreadMerge('__typeProps', typeOptionCodes);
    }
    if (useOption) {
        yield* generateSpreadMerge('props', getOptionCodes.map(fn => fn()));
    }
}
function* generateIntersectMerge(key, codes) {
    yield `${key}: {} as `;
    yield codes[0];
    for (let i = 1; i < codes.length; i++) {
        yield ` & `;
        yield codes[i];
    }
    yield `,${utils_1.newLine}`;
}
function* generateSpreadMerge(key, codes) {
    yield `${key}: `;
    if (codes.length === 1) {
        yield codes[0];
    }
    else {
        yield `{${utils_1.newLine}`;
        for (const code of codes) {
            yield `...`;
            yield code;
            yield `,${utils_1.newLine}`;
        }
        yield `}`;
    }
    yield `,${utils_1.newLine}`;
}
//# sourceMappingURL=component.js.map